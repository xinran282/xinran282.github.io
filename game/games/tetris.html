<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>俄罗斯方块</title>
<style>
:root {
    --wechat-green: #07c160;
    --wechat-gray: #f6f6f6;
    --wechat-dark: #333;
}

/* ====== 全局布局 ====== */
html, body {
    height: 100%;
    margin: 0;
    background: var(--wechat-gray);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    overflow: hidden;
}

/* ====== 顶部导航栏 ====== */
.navbar {
    height: 44px;
    background: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    font-size: 17px;
    font-weight: 600;
    color: var(--wechat-dark);
}
.navbar .nav-back {
    position: absolute;
    left: 10px;
    top: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    color: var(--wechat-green);
    font-size: 22px;
    text-decoration: none;
}
.navbar .nav-back::before {
    content: "‹";
    font-size: 28px;
    line-height: 44px;
}

/* ====== 状态栏 ====== */
.status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #fff;
    padding: 10px 16px;
    font-size: 15px;
    color: var(--wechat-dark);
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}
.status-bar b {
    color: var(--wechat-green);
    font-size: 18px;
    margin-left: 5px;
}
.status-bar .btn-restart {
    color: var(--wechat-green);
    font-weight: bold;
    cursor: pointer;
}

/* ====== 游戏区域 ====== */
.game-wrapper {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #e6e6e6;
    position: relative;
    height: calc(100% - 88px); /* 导航栏 + 状态栏 */
}

/* 画布自适应 */
canvas {
    background: #fff;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    display: block;
    width: 90vw;
    max-width: 420px;
    height: auto;
}

/* Toast 提示 */
.toast {
    position: fixed;
    bottom: 20%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: #fff;
    padding: 10px 16px;
    border-radius: 6px;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
    z-index: 99;
}
.toast.show {
    opacity: 1;
}
</style>
</head>
<body>
    <div class="navbar">
        <a href="../index.html" class="nav-back"></a>
        <div>俄罗斯方块</div>
    </div>

    <div class="status-bar">
        <span>得分<b id="score">0</b></span>
        <span class="btn-restart" onclick="game.reset()">重玩</span>
    </div>

    <div class="game-wrapper" id="gameWrapper">
        <canvas id="tetrisCanvas"></canvas>
    </div>

    <div id="toast" class="toast"></div>

<script>
/* ====== 游戏逻辑 ====== */
const SHAPES = [
    [],
    [[1,1,1,1]], // I
    [[1,1],[1,1]], // O
    [[0,1,0],[1,1,1]], // T
    [[1,0,0],[1,1,1]], // L
    [[0,0,1],[1,1,1]], // J
    [[0,1,1],[1,1,0]], // S
    [[1,1,0],[0,1,1]]  // Z
];
const COLORS = [
    null,
    '#3eb575','#e6c02a','#9c27b0','#fa5151','#10aeff','#07c160','#ff9800'
];

class Tetris {
    constructor() {
        this.canvas = document.getElementById('tetrisCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.wrapper = document.getElementById('gameWrapper');
        this.cols = 10;
        this.rows = 20;
        this.blockSize = 0;
        this.board = [];
        this.score = 0;
        this.isGameOver = false;
        this.dropInterval = 1000;
        this.dropCounter = 0;
        this.lastTime = 0;
        this.currPiece = null;
        this.currPos = {x:0,y:0};

        this.initLayout();
        window.addEventListener('resize', ()=>this.initLayout());
        this.bindControls();
        this.reset();
    }

    initLayout() {
        const w = this.wrapper.clientWidth;
        const h = this.wrapper.clientHeight;
        const sizeByW = Math.floor(w / this.cols);
        const sizeByH = Math.floor(h / this.rows);
        this.blockSize = Math.min(sizeByW, sizeByH);
        this.canvas.width = this.blockSize * this.cols;
        this.canvas.height = this.blockSize * this.rows;
        this.draw();
    }

    reset() {
        this.board = Array.from({length:this.rows},()=>Array(this.cols).fill(0));
        this.score = 0;
        this.updateScore();
        this.isGameOver = false;
        this.dropInterval = 1000;
        this.spawnPiece();
        this.dropCounter = 0;
        this.lastTime = 0;
        requestAnimationFrame(this.update.bind(this));
    }

    spawnPiece() {
        const id = Math.floor(Math.random()*7)+1;
        this.currPiece = SHAPES[id];
        this.currColor = COLORS[id];
        this.currPos.x = Math.floor((this.cols - this.currPiece[0].length)/2);
        this.currPos.y = 0;
        if (this.collide(this.currPos.x,this.currPos.y,this.currPiece)) {
            this.isGameOver = true;
            this.showToast(`游戏结束! 得分: ${this.score}`);
        }
    }

    collide(x,y,piece){
        for(let r=0;r<piece.length;r++){
            for(let c=0;c<piece[r].length;c++){
                if(piece[r][c]){
                    const nx=x+c, ny=y+r;
                    if(nx<0||nx>=this.cols||ny>=this.rows) return true;
                    if(ny>=0 && this.board[ny][nx]!==0) return true;
                }
            }
        }
        return false;
    }

    rotate(piece){
        const newP = piece[0].map((_,i)=>piece.map(r=>r[i]).reverse());
        if(this.collide(this.currPos.x,this.currPos.y,newP)){
            if(!this.collide(this.currPos.x-1,this.currPos.y,newP)) this.currPos.x--;
            else if(!this.collide(this.currPos.x+1,this.currPos.y,newP)) this.currPos.x++;
            else return piece;
        }
        return newP;
    }

    merge(){
        this.currPiece.forEach((row,r)=>{
            row.forEach((v,c)=>{
                if(v && this.currPos.y+r>=0)
                    this.board[this.currPos.y+r][this.currPos.x+c]=this.currColor;
            });
        });
    }

    clearLines(){
        let lines=0;
        for(let r=this.rows-1;r>=0;r--){
            if(this.board[r].every(v=>v!==0)){
                this.board.splice(r,1);
                this.board.unshift(Array(this.cols).fill(0));
                lines++;
                r++;
            }
        }
        if(lines>0){
            this.score+=lines*100;
            this.updateScore();
            this.dropInterval=Math.max(100,1000-this.score);
        }
    }

    drop(){
        this.currPos.y++;
        if(this.collide(this.currPos.x,this.currPos.y,this.currPiece)){
            this.currPos.y--;
            this.merge();
            this.clearLines();
            this.spawnPiece();
        }
        this.dropCounter=0;
    }

    hardDrop(){
        while(!this.collide(this.currPos.x,this.currPos.y+1,this.currPiece))
            this.currPos.y++;
        this.merge();
        this.clearLines();
        this.spawnPiece();
        this.dropCounter=0;
        this.draw();
    }

    move(dir){
        this.currPos.x+=dir;
        if(this.collide(this.currPos.x,this.currPos.y,this.currPiece))
            this.currPos.x-=dir;
        this.draw();
    }

    playerRotate(){
        this.currPiece=this.rotate(this.currPiece);
        this.draw();
    }

    update(time=0){
        if(this.isGameOver) return;
        const delta=time-this.lastTime;
        this.lastTime=time;
        this.dropCounter+=delta;
        if(this.dropCounter>this.dropInterval) this.drop();
        this.draw();
        requestAnimationFrame(this.update.bind(this));
    }

    draw(){
        this.ctx.fillStyle='#fff';
        this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
        this.board.forEach((row,r)=>{
            row.forEach((v,c)=>{
                if(v) this.drawBlock(c,r,v);
            });
        });
        if(this.currPiece){
            this.currPiece.forEach((row,r)=>{
                row.forEach((v,c)=>{
                    if(v) this.drawBlock(this.currPos.x+c,this.currPos.y+r,this.currColor);
                });
            });
        }
    }

    drawBlock(x,y,color){
        this.ctx.fillStyle=color;
        this.ctx.fillRect(x*this.blockSize,y*this.blockSize,this.blockSize,this.blockSize);
        this.ctx.strokeStyle='rgba(255,255,255,0.4)';
        this.ctx.strokeRect(x*this.blockSize,y*this.blockSize,this.blockSize,this.blockSize);
    }

    updateScore(){
        document.getElementById('score').innerText=this.score;
    }

    showToast(msg){
        const t=document.getElementById('toast');
        t.innerText=msg;
        t.classList.add('show');
        setTimeout(()=>t.classList.remove('show'),3000);
    }

    bindControls(){
        window.addEventListener('keydown',(e)=>{
            if(this.isGameOver)return;
            if(e.key==='ArrowLeft') this.move(-1);
            else if(e.key==='ArrowRight') this.move(1);
            else if(e.key==='ArrowUp') this.playerRotate();
            else if(e.key==='ArrowDown') this.hardDrop();
        });
    }
}

const game=new Tetris();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>俄罗斯方块</title>
<style>
:root {
    --wechat-green: #07c160;
    --wechat-gray: #f6f6f6;
    --wechat-dark: #333;
}

/* ====== 全局布局 ====== */
html, body {
    height: 100%;
    margin: 0;
    background: var(--wechat-gray);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    overflow: hidden;
}

/* ====== 顶部导航栏 ====== */
.navbar {
    height: 44px;
    background: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    font-size: 17px;
    font-weight: 600;
    color: var(--wechat-dark);
}
.navbar .nav-back {
    position: absolute;
    left: 10px;
    top: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    color: var(--wechat-green);
    font-size: 22px;
    text-decoration: none;
}
.navbar .nav-back::before {
    content: "‹";
    font-size: 28px;
    line-height: 44px;
}

/* ====== 状态栏 ====== */
.status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #fff;
    padding: 10px 16px;
    font-size: 15px;
    color: var(--wechat-dark);
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}
.status-bar b {
    color: var(--wechat-green);
    font-size: 18px;
    margin-left: 5px;
}
.status-bar .btn-restart {
    color: var(--wechat-green);
    font-weight: bold;
    cursor: pointer;
}

/* ====== 游戏区域 ====== */
.game-wrapper {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #e6e6e6;
    position: relative;
    height: calc(100% - 88px); /* 导航栏 + 状态栏 */
}

/* 画布自适应 */
canvas {
    background: #fff;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    display: block;
    width: 90vw;
    max-width: 420px;
    height: auto;
}

/* Toast 提示 */
.toast {
    position: fixed;
    bottom: 20%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: #fff;
    padding: 10px 16px;
    border-radius: 6px;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
    z-index: 99;
}
.toast.show {
    opacity: 1;
}
</style>
</head>
<body>
    <div class="navbar">
        <a href="index.html" class="nav-back"></a>
        <div>俄罗斯方块</div>
    </div>

    <div class="status-bar">
        <span>得分<b id="score">0</b></span>
        <span class="btn-restart" onclick="game.reset()">重玩</span>
    </div>

    <div class="game-wrapper" id="gameWrapper">
        <canvas id="tetrisCanvas"></canvas>
    </div>

    <div id="toast" class="toast"></div>

<script>
/* ====== 游戏逻辑 ====== */
const SHAPES = [
    [],
    [[1,1,1,1]], // I
    [[1,1],[1,1]], // O
    [[0,1,0],[1,1,1]], // T
    [[1,0,0],[1,1,1]], // L
    [[0,0,1],[1,1,1]], // J
    [[0,1,1],[1,1,0]], // S
    [[1,1,0],[0,1,1]]  // Z
];
const COLORS = [
    null,
    '#3eb575','#e6c02a','#9c27b0','#fa5151','#10aeff','#07c160','#ff9800'
];

class Tetris {
    constructor() {
        this.canvas = document.getElementById('tetrisCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.wrapper = document.getElementById('gameWrapper');
        this.cols = 10;
        this.rows = 20;
        this.blockSize = 0;
        this.board = [];
        this.score = 0;
        this.isGameOver = false;
        this.dropInterval = 1000;
        this.dropCounter = 0;
        this.lastTime = 0;
        this.currPiece = null;
        this.currPos = {x:0,y:0};

        this.initLayout();
        window.addEventListener('resize', ()=>this.initLayout());
        this.bindControls();
        this.reset();
    }

    initLayout() {
        const w = this.wrapper.clientWidth;
        const h = this.wrapper.clientHeight;
        const sizeByW = Math.floor(w / this.cols);
        const sizeByH = Math.floor(h / this.rows);
        this.blockSize = Math.min(sizeByW, sizeByH);
        this.canvas.width = this.blockSize * this.cols;
        this.canvas.height = this.blockSize * this.rows;
        this.draw();
    }

    reset() {
        this.board = Array.from({length:this.rows},()=>Array(this.cols).fill(0));
        this.score = 0;
        this.updateScore();
        this.isGameOver = false;
        this.dropInterval = 1000;
        this.spawnPiece();
        this.dropCounter = 0;
        this.lastTime = 0;
        requestAnimationFrame(this.update.bind(this));
    }

    spawnPiece() {
        const id = Math.floor(Math.random()*7)+1;
        this.currPiece = SHAPES[id];
        this.currColor = COLORS[id];
        this.currPos.x = Math.floor((this.cols - this.currPiece[0].length)/2);
        this.currPos.y = 0;
        if (this.collide(this.currPos.x,this.currPos.y,this.currPiece)) {
            this.isGameOver = true;
            this.showToast(`游戏结束! 得分: ${this.score}`);
        }
    }

    collide(x,y,piece){
        for(let r=0;r<piece.length;r++){
            for(let c=0;c<piece[r].length;c++){
                if(piece[r][c]){
                    const nx=x+c, ny=y+r;
                    if(nx<0||nx>=this.cols||ny>=this.rows) return true;
                    if(ny>=0 && this.board[ny][nx]!==0) return true;
                }
            }
        }
        return false;
    }

    rotate(piece){
        const newP = piece[0].map((_,i)=>piece.map(r=>r[i]).reverse());
        if(this.collide(this.currPos.x,this.currPos.y,newP)){
            if(!this.collide(this.currPos.x-1,this.currPos.y,newP)) this.currPos.x--;
            else if(!this.collide(this.currPos.x+1,this.currPos.y,newP)) this.currPos.x++;
            else return piece;
        }
        return newP;
    }

    merge(){
        this.currPiece.forEach((row,r)=>{
            row.forEach((v,c)=>{
                if(v && this.currPos.y+r>=0)
                    this.board[this.currPos.y+r][this.currPos.x+c]=this.currColor;
            });
        });
    }

    clearLines(){
        let lines=0;
        for(let r=this.rows-1;r>=0;r--){
            if(this.board[r].every(v=>v!==0)){
                this.board.splice(r,1);
                this.board.unshift(Array(this.cols).fill(0));
                lines++;
                r++;
            }
        }
        if(lines>0){
            this.score+=lines*100;
            this.updateScore();
            this.dropInterval=Math.max(100,1000-this.score);
        }
    }

    drop(){
        this.currPos.y++;
        if(this.collide(this.currPos.x,this.currPos.y,this.currPiece)){
            this.currPos.y--;
            this.merge();
            this.clearLines();
            this.spawnPiece();
        }
        this.dropCounter=0;
    }

    hardDrop(){
        while(!this.collide(this.currPos.x,this.currPos.y+1,this.currPiece))
            this.currPos.y++;
        this.merge();
        this.clearLines();
        this.spawnPiece();
        this.dropCounter=0;
        this.draw();
    }

    move(dir){
        this.currPos.x+=dir;
        if(this.collide(this.currPos.x,this.currPos.y,this.currPiece))
            this.currPos.x-=dir;
        this.draw();
    }

    playerRotate(){
        this.currPiece=this.rotate(this.currPiece);
        this.draw();
    }

    update(time=0){
        if(this.isGameOver) return;
        const delta=time-this.lastTime;
        this.lastTime=time;
        this.dropCounter+=delta;
        if(this.dropCounter>this.dropInterval) this.drop();
        this.draw();
        requestAnimationFrame(this.update.bind(this));
    }

    draw(){
        this.ctx.fillStyle='#fff';
        this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
        this.board.forEach((row,r)=>{
            row.forEach((v,c)=>{
                if(v) this.drawBlock(c,r,v);
            });
        });
        if(this.currPiece){
            this.currPiece.forEach((row,r)=>{
                row.forEach((v,c)=>{
                    if(v) this.drawBlock(this.currPos.x+c,this.currPos.y+r,this.currColor);
                });
            });
        }
    }

    drawBlock(x,y,color){
        this.ctx.fillStyle=color;
        this.ctx.fillRect(x*this.blockSize,y*this.blockSize,this.blockSize,this.blockSize);
        this.ctx.strokeStyle='rgba(255,255,255,0.4)';
        this.ctx.strokeRect(x*this.blockSize,y*this.blockSize,this.blockSize,this.blockSize);
    }

    updateScore(){
        document.getElementById('score').innerText=this.score;
    }

    showToast(msg){
        const t=document.getElementById('toast');
        t.innerText=msg;
        t.classList.add('show');
        setTimeout(()=>t.classList.remove('show'),3000);
    }

    bindControls(){
        window.addEventListener('keydown',(e)=>{
            if(this.isGameOver)return;
            if(e.key==='ArrowLeft') this.move(-1);
            else if(e.key==='ArrowRight') this.move(1);
            else if(e.key==='ArrowUp') this.playerRotate();
            else if(e.key==='ArrowDown') this.hardDrop();
        });
    }
}

const game=new Tetris();
</script>
</body>
</html>
