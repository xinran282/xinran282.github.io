<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>贪吃蛇</title>
<style>
:root {
  --wechat-green: #07c160;
  --wechat-gray: #f6f6f6;
  --wechat-dark: #333;
}

/* ====== 全局 ====== */
html, body {
  margin: 0;
  padding: 0;
  background: var(--wechat-gray);
  height: 100%;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  overflow: hidden;
}

/* ====== 顶部导航栏 ====== */
.navbar {
  height: 44px;
  background: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
  font-size: 17px;
  font-weight: 600;
  color: var(--wechat-dark);
}
.navbar .nav-back {
  position: absolute;
  left: 10px;
  top: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  color: var(--wechat-green);
  font-size: 22px;
  text-decoration: none;
}
.navbar .nav-back::before {
  content: "‹";
  font-size: 28px;
  line-height: 44px;
}

/* ====== 状态栏 ====== */
.status-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: #fff;
  padding: 10px 16px;
  font-size: 15px;
  color: var(--wechat-dark);
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}
.status-bar b {
  color: var(--wechat-green);
  font-size: 18px;
  margin-left: 5px;
}
.status-bar .btn-restart {
  color: var(--wechat-green);
  font-weight: bold;
  cursor: pointer;
}

/* ====== 游戏区域 ====== */
.game-wrapper {
  display: flex;
  justify-content: center;
  align-items: center;
  background: #e6e6e6;
  position: relative;
  height: calc(var(--vh, 1vh) * 100 - 88px); /* 动态计算 */
}
canvas {
  background: #fff;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  display: block;
  width: 90vw;
  max-width: 420px;
  aspect-ratio: 1 / 1;
}

/* ====== Toast 提示 ====== */
.toast {
  position: fixed;
  bottom: 20%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.8);
  color: #fff;
  padding: 10px 16px;
  border-radius: 6px;
  opacity: 0;
  transition: opacity 0.3s;
  pointer-events: none;
  z-index: 99;
}
.toast.show {
  opacity: 1;
}
</style>
</head>
<body>
  <div class="navbar">
    <a href="../index.html" class="nav-back"></a>
    <div>贪吃蛇</div>
  </div>

  <div class="status-bar">
    <span>得分<b id="score">0</b></span>
    <span class="btn-restart" onclick="snakeGame.reset()">重玩</span>
  </div>

  <div class="game-wrapper" id="gameWrapper">
    <canvas id="snakeCanvas"></canvas>
  </div>

  <div id="toast" class="toast"></div>

<script>
/* ====== 修复移动端高度计算 ====== */
function setVh() {
  const vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty('--vh', `${vh}px`);
}
window.addEventListener('resize', setVh);
window.addEventListener('orientationchange', setVh);
setVh();

/* ====== 贪吃蛇游戏逻辑 ====== */
class SnakeGame {
  constructor() {
    this.canvas = document.getElementById('snakeCanvas');
    this.ctx = this.canvas.getContext('2d');
    this.cols = 20;
    this.rows = 20;
    this.blockSize = 0;
    this.snake = [];
    this.direction = {x: 1, y: 0};
    this.food = null;
    this.score = 0;
    this.isGameOver = false;
    this.speed = 200;
    this.timer = null;

    this.initLayout();
    window.addEventListener('resize', () => this.initLayout());
    this.bindControls();
    this.reset();
  }

  initLayout() {
    const size = Math.min(this.canvas.clientWidth, this.canvas.clientHeight);
    this.blockSize = Math.floor(size / this.cols);
    this.canvas.width = this.blockSize * this.cols;
    this.canvas.height = this.blockSize * this.rows;
  }

  reset() {
    this.snake = [{x:5, y:10}, {x:4, y:10}, {x:3, y:10}];
    this.direction = {x:1, y:0};
    this.score = 0;
    this.isGameOver = false;
    this.spawnFood();
    this.updateScore();
    clearInterval(this.timer);
    this.timer = setInterval(() => this.update(), this.speed);
    this.draw();
  }

  spawnFood() {
    let newFood;
    do {
      newFood = {
        x: Math.floor(Math.random() * this.cols),
        y: Math.floor(Math.random() * this.rows)
      };
    } while (this.snake.some(s => s.x === newFood.x && s.y === newFood.y));
    this.food = newFood;
  }

  update() {
    if (this.isGameOver) return;
    const head = {x: this.snake[0].x + this.direction.x, y: this.snake[0].y + this.direction.y};

    if (head.x < 0 || head.y < 0 || head.x >= this.cols || head.y >= this.rows ||
        this.snake.some(s => s.x === head.x && s.y === head.y)) {
      this.gameOver();
      return;
    }

    this.snake.unshift(head);
    if (head.x === this.food.x && head.y === this.food.y) {
      this.score += 10;
      this.updateScore();
      this.spawnFood();
    } else {
      this.snake.pop();
    }
    this.draw();
  }

  draw() {
    this.ctx.fillStyle = "#fff";
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    // 食物
    this.ctx.fillStyle = "#fa5151";
    this.ctx.fillRect(this.food.x*this.blockSize, this.food.y*this.blockSize, this.blockSize, this.blockSize);

    // 蛇
    this.ctx.fillStyle = "#07c160";
    this.snake.forEach(s => {
      this.ctx.fillRect(s.x*this.blockSize, s.y*this.blockSize, this.blockSize, this.blockSize);
    });
  }

  gameOver() {
    this.isGameOver = true;
    clearInterval(this.timer);
    this.showToast(`游戏结束! 得分: ${this.score}`);
  }

  updateScore() {
    document.getElementById('score').innerText = this.score;
  }

  showToast(msg) {
    const t = document.getElementById('toast');
    t.innerText = msg;
    t.classList.add('show');
    setTimeout(() => t.classList.remove('show'), 3000);
  }

  bindControls() {
    window.addEventListener('keydown', e => {
      if (this.isGameOver) return;
      if (e.key === 'ArrowUp' && this.direction.y === 0) this.direction = {x:0, y:-1};
      else if (e.key === 'ArrowDown' && this.direction.y === 0) this.direction = {x:0, y:1};
      else if (e.key === 'ArrowLeft' && this.direction.x === 0) this.direction = {x:-1, y:0};
      else if (e.key === 'ArrowRight' && this.direction.x === 0) this.direction = {x:1, y:0};
    });

    // 点击屏幕自动判断方向
    this.canvas.addEventListener('click', e => {
      if (this.isGameOver) return;
      const rect = this.canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      const head = this.snake[0];
      const headCenter = {
        x: (head.x + 0.5) * this.blockSize,
        y: (head.y + 0.5) * this.blockSize
      };
      const dx = clickX - headCenter.x;
      const dy = clickY - headCenter.y;

      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 0 && this.direction.x === 0) this.direction = {x:1, y:0};
        else if (dx < 0 && this.direction.x === 0) this.direction = {x:-1, y:0};
      } else {
        if (dy > 0 && this.direction.y === 0) this.direction = {x:0, y:1};
        else if (dy < 0 && this.direction.y === 0) this.direction = {x:0, y:-1};
      }
    });
  }
}

const snakeGame = new SnakeGame();
</script>
</body>
</html>
